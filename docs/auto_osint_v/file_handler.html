<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>auto_osint_v.file_handler API documentation</title>
<meta name="description" content="This module handles all our data files. CSV or TXT." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>auto_osint_v.file_handler</code></h1>
</header>
<section id="section-intro">
<p>This module handles all our data files. CSV or TXT.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;This module handles all our data files. CSV or TXT.
&#34;&#34;&#34;

import csv
import os
import webbrowser
import pandas as pd


class FileHandler:
    &#34;&#34;&#34;FileHandler class handles anything file related for the whole tool.

    This can be created as an object once and reused multiple times.
    &#34;&#34;&#34;
    def __init__(self, data_file):
        &#34;&#34;&#34;Initialises the FileHandler object

        Args:
            data_file: the file path for all data files - likely &#39;./data_files/&#39;.
        &#34;&#34;&#34;
        # empty list to hold unique urls present after searching
        self.urls_present = []
        self.data_file_path = data_file

    def write_bias_file(self, info_analyser):
        &#34;&#34;&#34;Creates and writes to the bias information file.

        This bias information is only useful for the user if they want to include information that
        the tool cannot use, but may be relevant to their analysis or conclusions.

        Returns:
            nothing - output to file
        &#34;&#34;&#34;
        bias_file_path = str(os.path.join(self.data_file_path, &#34;bias_sources.csv&#34;))
        with open(bias_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as bfile:
            fieldnames = [&#39;Type/Link&#39;, &#39;Key Info&#39;, &#39;Info Sentiment&#39;]
            writer = csv.DictWriter(bfile, fieldnames)
            # enter source type and key information
            writer.writeheader()
            option = &#34;&#34;
            while option not in {&#34;x&#34;, &#34;X&#34;}:
                source_type = str(input(&#34;If you wish to enter a source that has no URL, just enter &#34;
                                        &#34;the type of source (e.g. HUMINT, SIGINT, etc.).&#34;
                                        &#34;If it is an open source, please enter the URL.\n&gt;&gt;&gt; &#34;))
                key_info = str(input(&#34;Enter the key information proffered &#34;
                                     &#34;from this source/intelligence\n&gt;&gt;&gt; &#34;))
                writer.writerow({&#34;Type/Link&#34;: source_type, &#34;Key Info&#34;: key_info,
                                 &#34;Info Sentiment&#34;: info_analyser(key_info)})
                option = str(input(&#34;Enter &#39;X&#39; to finish entering sources. &#34;
                                   &#34;Press ENTER to add another source&gt;&gt;&gt; &#34;))
            bfile.close()

    def read_bias_file(self):
        bias_file_path = str(os.path.join(self.data_file_path, &#34;bias_sources.csv&#34;))
        with open(bias_file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as bfile:
            reader = csv.DictReader(bfile)
            list_of_dicts = list(reader)
            return list_of_dicts

    def write_intel_file(self, editor: bool):
        &#34;&#34;&#34;Creates and writes a file for the intelligence statement to be stored in.

        This opens the file in the text editor for easier statement writing.

        Returns:
            nothing - output to file
        &#34;&#34;&#34;
        intel_file_path = str(os.path.join(self.data_file_path, &#34;intelligence_file.txt&#34;))
        if os.path.isfile(intel_file_path):
            os.remove(intel_file_path)
        with open(intel_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as fout:
            # Create file and close as will be edited in txt editor.
            statement_help = str(&#34;Intelligence statement help:\n&#34;
                                 &#34;- Please include as much information as possible.\n&#34;
                                 &#34;- Include known associates to the person(s) mentioned.\n&#34;
                                 &#34;- Remove this help section and replace it with your &#34;
                                 &#34;intelligence statement.\n&#34;
                                 &#34;- Be sure to save the file before continuing.&#34;)
            if editor:
                fout.write(statement_help)
                fout.close()
                webbrowser.open(intel_file_path)  # edit in default text editor
            else:
                statement = str(input(statement_help))
                fout.write(statement)
                fout.close()

    def read_file(self, filename):
        &#34;&#34;&#34;Reads the given file. Reads any file, extension is included in filename.

        Args:
            filename: includes the file extension.

        Returns:
            the contents of the file
        &#34;&#34;&#34;
        file_path = str(os.path.join(self.data_file_path, filename))
        with open(file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as file:
            temp = file.read()
            file.close()
            return temp

    def get_keywords_from_target_info(self):
        &#34;&#34;&#34;Gets all the information that is stored in the &#39;Info&#39; field in each target info file.

        Returns:
            All the info stored in /target_info_files/
        &#34;&#34;&#34;
        # List of words that have no meaning without context
        irrelevant_words = [&#34;it&#34;, &#34;them&#34;, &#34;they&#34;, &#34;the&#34;, &#34;he&#34;, &#34;she&#34;, &#34;his&#34;, &#34;her&#34;, &#34;we&#34;, &#34;i&#34;,
                            &#34;us&#34;, &#34;me&#34;, &#34;my&#34;, &#34;here&#34;, &#34;our&#34;]
        # the directory to find the target info files
        target_files_dir = os.path.join(self.data_file_path, &#34;target_info_files/&#34;)
        # list target info files
        target_files = os.listdir(target_files_dir)
        # Create list to store keywords
        info_all = []
        # read each file individually
        for file in target_files:
            filepath = os.path.join(target_files_dir, file)
            frame = pd.read_csv(filepath, index_col=False)
            # appends every entry in the &#39;info&#39; column to the &#39;info_all&#39; list unless
            # it is irrelevant
            values = frame[&#34;Info&#34;].values.tolist()
            info_all.extend(values)
        # remove irrelevant words
        info_all = [word for word in info_all if word not in irrelevant_words]
        # return list after each file has been examined
        return info_all

    @staticmethod
    def clean_directory(directory):
        &#34;&#34;&#34;Cleans the given directory. Removes all files inside.
        &#34;&#34;&#34;
        try:
            for file in os.listdir(directory):
                os.remove(os.path.join(directory, file))
        except FileNotFoundError:
            pass

    def clean_data_file(self, filename):
        &#34;&#34;&#34;Removes all data in given file

        Args:
            filename: name of file, can be path relative to &#39;data_files&#39; directory
        &#34;&#34;&#34;
        try:
            os.remove(os.path.join(self.data_file_path, filename))
        except FileNotFoundError:
            pass

    @staticmethod
    def write_to_given_csv_file(file_object, to_write):
        &#34;&#34;&#34;Writes given text to a given file object.

        Args:
            to_write: iterable to write to the csv file
            file_object: the file object, created when opening a file
                (e.g., &#34;with open(file) as file_object:&#34;)

        Returns:
            Nothing
        &#34;&#34;&#34;
        try:
            writer = csv.writer(file_object, delimiter=&#39;,&#39;)
            writer.writerow(to_write)  # writes a row of the csv file using the list &#39;to_files&#39;
        except ValueError as exc:
            raise ValueError(
                &#34;I/O operation on closed file. Issue with FileHandler.open_label_file&#34;) \
                from exc

    def write_to_txt_file_remove_duplicates(self, file_object, to_write):
        &#34;&#34;&#34;Writes the given text and ensures no duplicates are written.

        Args:
            file_object: File object passed from opening the file.
            to_write: The text to write.
        &#34;&#34;&#34;
        # check whether lines are unique
        if to_write not in self.urls_present:
            # write to file
            file_object.write(to_write + &#34;\n&#34;)
            # add unique line to lines_present lines
            self.urls_present.append(to_write)

    def open_txt_file(self, filename):
        &#34;&#34;&#34;Opens a file or creates one if it does not exist, returns the fileIO object.

        Clean every temp file created here by using clean_directory.

        Args:
            filename: name of file to open

        Returns:
            file object
        &#34;&#34;&#34;
        try:
            return open(os.path.join(self.data_file_path, filename), &#34;a&#34;, encoding=&#34;utf-8&#34;)
        except FileNotFoundError:
            return open(os.path.join(self.data_file_path, filename), &#34;w&#34;, encoding=&#34;utf-8&#34;)

    @staticmethod
    def close_file(file_object):
        &#34;&#34;&#34;Closes a given file.

        Args:
            file_object: The file object for the file to be closed

        Returns:
            nothing, just closes a file.
        &#34;&#34;&#34;
        file_object.close()

    def open_label_file(self, label, text, mentions):
        &#34;&#34;&#34;Creates/Opens label file directory and the label file itself.

        Args:
            text: The labelled word
            mentions: The number of times the text has appeared.
            label: This will be the name for the label file. This is the label associated with a
                word

        Returns:
            Nothing - output to file
        &#34;&#34;&#34;
        label_files_directory = self.data_file_path + &#34;target_info_files&#34;
        try:
            os.mkdir(label_files_directory)
            file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
        except FileExistsError:
            file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
        fieldnames = [&#39;Info&#39;, &#39;Mentions&#39;]
        try:
            with open(file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as label_file:
                # Creation of csv file
                writer = csv.DictWriter(label_file, fieldnames)
                # enter source type and key information
                writer.writeheader()
                # Write info to csv
                to_write = [text, mentions]
                self.write_to_given_csv_file(label_file, to_write)
        except FileExistsError:
            with open(file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as label_file:
                # Write info to csv
                to_write = [text, mentions]
                self.write_to_given_csv_file(label_file, to_write)

    def open_evidence_file(self, to_write):
        &#34;&#34;&#34;Creates/Opens evidence file and writes to it.

        Args:
            to_write: List of elements to write to file

        Returns:
            Nothing - output to file
        &#34;&#34;&#34;
        evidence_file_path = self.data_file_path + &#34;evidence_file.csv&#34;
        fieldnames = [&#34;evidence type&#34;, &#34;info&#34;, &#34;extra info&#34;, &#34;score&#34;, &#34;source link&#34;]
        try:
            with open(evidence_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
                # Creation of csv file
                writer = csv.DictWriter(evidence_file, fieldnames)
                writer.writeheader()
                # Write info to csv
                self.write_to_given_csv_file(evidence_file, to_write)
        except FileExistsError:
            with open(evidence_file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
                # Append info to csv
                self.write_to_given_csv_file(evidence_file, to_write)

    def read_evidence_file(self):
        evidence_file_path = self.data_file_path + &#34;evidence_file.csv&#34;
        with open(evidence_file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
            reader = csv.DictReader(evidence_file)
            list_of_dicts = list(reader)
            return list_of_dicts

    def create_potential_corroboration_file(self, sources_list_of_dicts):
        &#34;&#34;&#34;Creates the potential corroboration source store.

        Writes the list of dictionaries to a csv file.

        Args:
            sources_list_of_dicts: Must be a list of dictionaries ( list[dict[x,y]] )

        Returns:
            nothing, outputs to file
        &#34;&#34;&#34;
        sources_file_path = self.data_file_path + &#34;potential_corroboration.csv&#34;
        try:
            self.clean_data_file(&#34;potential_corroboration.csv&#34;)
        except FileNotFoundError:
            pass
        # get keys of dictionary and store as fieldnames
        fieldnames = sources_list_of_dicts[0].keys()
        with open(sources_file_path, &#34;x&#34;, newline=&#34;&#34;, encoding=&#34;utf-8&#34;) as sources_file:
            # create writer object
            writer = csv.DictWriter(sources_file, fieldnames)
            writer.writeheader()
            # write the dictionary to csv
            writer.writerows(sources_list_of_dicts)

    def get_output_path(self, postfix, file_ext):
        &#34;&#34;&#34;Gets the path of the output file&#34;&#34;&#34;
        output_directory = self.data_file_path + &#34;output&#34;
        try:
            os.mkdir(output_directory)
            file_path = str(os.path.join(output_directory, f&#34;output{postfix}.{file_ext}&#34;))
        except FileExistsError:
            file_path = str(os.path.join(output_directory, f&#34;output{postfix}.{file_ext}&#34;))
        return file_path</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="auto_osint_v.file_handler.FileHandler"><code class="flex name class">
<span>class <span class="ident">FileHandler</span></span>
<span>(</span><span>data_file)</span>
</code></dt>
<dd>
<div class="desc"><p>FileHandler class handles anything file related for the whole tool.</p>
<p>This can be created as an object once and reused multiple times.</p>
<p>Initialises the FileHandler object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_file</code></strong></dt>
<dd>the file path for all data files - likely './data_files/'.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileHandler:
    &#34;&#34;&#34;FileHandler class handles anything file related for the whole tool.

    This can be created as an object once and reused multiple times.
    &#34;&#34;&#34;
    def __init__(self, data_file):
        &#34;&#34;&#34;Initialises the FileHandler object

        Args:
            data_file: the file path for all data files - likely &#39;./data_files/&#39;.
        &#34;&#34;&#34;
        # empty list to hold unique urls present after searching
        self.urls_present = []
        self.data_file_path = data_file

    def write_bias_file(self, info_analyser):
        &#34;&#34;&#34;Creates and writes to the bias information file.

        This bias information is only useful for the user if they want to include information that
        the tool cannot use, but may be relevant to their analysis or conclusions.

        Returns:
            nothing - output to file
        &#34;&#34;&#34;
        bias_file_path = str(os.path.join(self.data_file_path, &#34;bias_sources.csv&#34;))
        with open(bias_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as bfile:
            fieldnames = [&#39;Type/Link&#39;, &#39;Key Info&#39;, &#39;Info Sentiment&#39;]
            writer = csv.DictWriter(bfile, fieldnames)
            # enter source type and key information
            writer.writeheader()
            option = &#34;&#34;
            while option not in {&#34;x&#34;, &#34;X&#34;}:
                source_type = str(input(&#34;If you wish to enter a source that has no URL, just enter &#34;
                                        &#34;the type of source (e.g. HUMINT, SIGINT, etc.).&#34;
                                        &#34;If it is an open source, please enter the URL.\n&gt;&gt;&gt; &#34;))
                key_info = str(input(&#34;Enter the key information proffered &#34;
                                     &#34;from this source/intelligence\n&gt;&gt;&gt; &#34;))
                writer.writerow({&#34;Type/Link&#34;: source_type, &#34;Key Info&#34;: key_info,
                                 &#34;Info Sentiment&#34;: info_analyser(key_info)})
                option = str(input(&#34;Enter &#39;X&#39; to finish entering sources. &#34;
                                   &#34;Press ENTER to add another source&gt;&gt;&gt; &#34;))
            bfile.close()

    def read_bias_file(self):
        bias_file_path = str(os.path.join(self.data_file_path, &#34;bias_sources.csv&#34;))
        with open(bias_file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as bfile:
            reader = csv.DictReader(bfile)
            list_of_dicts = list(reader)
            return list_of_dicts

    def write_intel_file(self, editor: bool):
        &#34;&#34;&#34;Creates and writes a file for the intelligence statement to be stored in.

        This opens the file in the text editor for easier statement writing.

        Returns:
            nothing - output to file
        &#34;&#34;&#34;
        intel_file_path = str(os.path.join(self.data_file_path, &#34;intelligence_file.txt&#34;))
        if os.path.isfile(intel_file_path):
            os.remove(intel_file_path)
        with open(intel_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as fout:
            # Create file and close as will be edited in txt editor.
            statement_help = str(&#34;Intelligence statement help:\n&#34;
                                 &#34;- Please include as much information as possible.\n&#34;
                                 &#34;- Include known associates to the person(s) mentioned.\n&#34;
                                 &#34;- Remove this help section and replace it with your &#34;
                                 &#34;intelligence statement.\n&#34;
                                 &#34;- Be sure to save the file before continuing.&#34;)
            if editor:
                fout.write(statement_help)
                fout.close()
                webbrowser.open(intel_file_path)  # edit in default text editor
            else:
                statement = str(input(statement_help))
                fout.write(statement)
                fout.close()

    def read_file(self, filename):
        &#34;&#34;&#34;Reads the given file. Reads any file, extension is included in filename.

        Args:
            filename: includes the file extension.

        Returns:
            the contents of the file
        &#34;&#34;&#34;
        file_path = str(os.path.join(self.data_file_path, filename))
        with open(file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as file:
            temp = file.read()
            file.close()
            return temp

    def get_keywords_from_target_info(self):
        &#34;&#34;&#34;Gets all the information that is stored in the &#39;Info&#39; field in each target info file.

        Returns:
            All the info stored in /target_info_files/
        &#34;&#34;&#34;
        # List of words that have no meaning without context
        irrelevant_words = [&#34;it&#34;, &#34;them&#34;, &#34;they&#34;, &#34;the&#34;, &#34;he&#34;, &#34;she&#34;, &#34;his&#34;, &#34;her&#34;, &#34;we&#34;, &#34;i&#34;,
                            &#34;us&#34;, &#34;me&#34;, &#34;my&#34;, &#34;here&#34;, &#34;our&#34;]
        # the directory to find the target info files
        target_files_dir = os.path.join(self.data_file_path, &#34;target_info_files/&#34;)
        # list target info files
        target_files = os.listdir(target_files_dir)
        # Create list to store keywords
        info_all = []
        # read each file individually
        for file in target_files:
            filepath = os.path.join(target_files_dir, file)
            frame = pd.read_csv(filepath, index_col=False)
            # appends every entry in the &#39;info&#39; column to the &#39;info_all&#39; list unless
            # it is irrelevant
            values = frame[&#34;Info&#34;].values.tolist()
            info_all.extend(values)
        # remove irrelevant words
        info_all = [word for word in info_all if word not in irrelevant_words]
        # return list after each file has been examined
        return info_all

    @staticmethod
    def clean_directory(directory):
        &#34;&#34;&#34;Cleans the given directory. Removes all files inside.
        &#34;&#34;&#34;
        try:
            for file in os.listdir(directory):
                os.remove(os.path.join(directory, file))
        except FileNotFoundError:
            pass

    def clean_data_file(self, filename):
        &#34;&#34;&#34;Removes all data in given file

        Args:
            filename: name of file, can be path relative to &#39;data_files&#39; directory
        &#34;&#34;&#34;
        try:
            os.remove(os.path.join(self.data_file_path, filename))
        except FileNotFoundError:
            pass

    @staticmethod
    def write_to_given_csv_file(file_object, to_write):
        &#34;&#34;&#34;Writes given text to a given file object.

        Args:
            to_write: iterable to write to the csv file
            file_object: the file object, created when opening a file
                (e.g., &#34;with open(file) as file_object:&#34;)

        Returns:
            Nothing
        &#34;&#34;&#34;
        try:
            writer = csv.writer(file_object, delimiter=&#39;,&#39;)
            writer.writerow(to_write)  # writes a row of the csv file using the list &#39;to_files&#39;
        except ValueError as exc:
            raise ValueError(
                &#34;I/O operation on closed file. Issue with FileHandler.open_label_file&#34;) \
                from exc

    def write_to_txt_file_remove_duplicates(self, file_object, to_write):
        &#34;&#34;&#34;Writes the given text and ensures no duplicates are written.

        Args:
            file_object: File object passed from opening the file.
            to_write: The text to write.
        &#34;&#34;&#34;
        # check whether lines are unique
        if to_write not in self.urls_present:
            # write to file
            file_object.write(to_write + &#34;\n&#34;)
            # add unique line to lines_present lines
            self.urls_present.append(to_write)

    def open_txt_file(self, filename):
        &#34;&#34;&#34;Opens a file or creates one if it does not exist, returns the fileIO object.

        Clean every temp file created here by using clean_directory.

        Args:
            filename: name of file to open

        Returns:
            file object
        &#34;&#34;&#34;
        try:
            return open(os.path.join(self.data_file_path, filename), &#34;a&#34;, encoding=&#34;utf-8&#34;)
        except FileNotFoundError:
            return open(os.path.join(self.data_file_path, filename), &#34;w&#34;, encoding=&#34;utf-8&#34;)

    @staticmethod
    def close_file(file_object):
        &#34;&#34;&#34;Closes a given file.

        Args:
            file_object: The file object for the file to be closed

        Returns:
            nothing, just closes a file.
        &#34;&#34;&#34;
        file_object.close()

    def open_label_file(self, label, text, mentions):
        &#34;&#34;&#34;Creates/Opens label file directory and the label file itself.

        Args:
            text: The labelled word
            mentions: The number of times the text has appeared.
            label: This will be the name for the label file. This is the label associated with a
                word

        Returns:
            Nothing - output to file
        &#34;&#34;&#34;
        label_files_directory = self.data_file_path + &#34;target_info_files&#34;
        try:
            os.mkdir(label_files_directory)
            file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
        except FileExistsError:
            file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
        fieldnames = [&#39;Info&#39;, &#39;Mentions&#39;]
        try:
            with open(file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as label_file:
                # Creation of csv file
                writer = csv.DictWriter(label_file, fieldnames)
                # enter source type and key information
                writer.writeheader()
                # Write info to csv
                to_write = [text, mentions]
                self.write_to_given_csv_file(label_file, to_write)
        except FileExistsError:
            with open(file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as label_file:
                # Write info to csv
                to_write = [text, mentions]
                self.write_to_given_csv_file(label_file, to_write)

    def open_evidence_file(self, to_write):
        &#34;&#34;&#34;Creates/Opens evidence file and writes to it.

        Args:
            to_write: List of elements to write to file

        Returns:
            Nothing - output to file
        &#34;&#34;&#34;
        evidence_file_path = self.data_file_path + &#34;evidence_file.csv&#34;
        fieldnames = [&#34;evidence type&#34;, &#34;info&#34;, &#34;extra info&#34;, &#34;score&#34;, &#34;source link&#34;]
        try:
            with open(evidence_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
                # Creation of csv file
                writer = csv.DictWriter(evidence_file, fieldnames)
                writer.writeheader()
                # Write info to csv
                self.write_to_given_csv_file(evidence_file, to_write)
        except FileExistsError:
            with open(evidence_file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
                # Append info to csv
                self.write_to_given_csv_file(evidence_file, to_write)

    def read_evidence_file(self):
        evidence_file_path = self.data_file_path + &#34;evidence_file.csv&#34;
        with open(evidence_file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
            reader = csv.DictReader(evidence_file)
            list_of_dicts = list(reader)
            return list_of_dicts

    def create_potential_corroboration_file(self, sources_list_of_dicts):
        &#34;&#34;&#34;Creates the potential corroboration source store.

        Writes the list of dictionaries to a csv file.

        Args:
            sources_list_of_dicts: Must be a list of dictionaries ( list[dict[x,y]] )

        Returns:
            nothing, outputs to file
        &#34;&#34;&#34;
        sources_file_path = self.data_file_path + &#34;potential_corroboration.csv&#34;
        try:
            self.clean_data_file(&#34;potential_corroboration.csv&#34;)
        except FileNotFoundError:
            pass
        # get keys of dictionary and store as fieldnames
        fieldnames = sources_list_of_dicts[0].keys()
        with open(sources_file_path, &#34;x&#34;, newline=&#34;&#34;, encoding=&#34;utf-8&#34;) as sources_file:
            # create writer object
            writer = csv.DictWriter(sources_file, fieldnames)
            writer.writeheader()
            # write the dictionary to csv
            writer.writerows(sources_list_of_dicts)

    def get_output_path(self, postfix, file_ext):
        &#34;&#34;&#34;Gets the path of the output file&#34;&#34;&#34;
        output_directory = self.data_file_path + &#34;output&#34;
        try:
            os.mkdir(output_directory)
            file_path = str(os.path.join(output_directory, f&#34;output{postfix}.{file_ext}&#34;))
        except FileExistsError:
            file_path = str(os.path.join(output_directory, f&#34;output{postfix}.{file_ext}&#34;))
        return file_path</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="auto_osint_v.file_handler.FileHandler.clean_directory"><code class="name flex">
<span>def <span class="ident">clean_directory</span></span>(<span>directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Cleans the given directory. Removes all files inside.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def clean_directory(directory):
    &#34;&#34;&#34;Cleans the given directory. Removes all files inside.
    &#34;&#34;&#34;
    try:
        for file in os.listdir(directory):
            os.remove(os.path.join(directory, file))
    except FileNotFoundError:
        pass</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.close_file"><code class="name flex">
<span>def <span class="ident">close_file</span></span>(<span>file_object)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes a given file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_object</code></strong></dt>
<dd>The file object for the file to be closed</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>nothing, just closes a file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def close_file(file_object):
    &#34;&#34;&#34;Closes a given file.

    Args:
        file_object: The file object for the file to be closed

    Returns:
        nothing, just closes a file.
    &#34;&#34;&#34;
    file_object.close()</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.write_to_given_csv_file"><code class="name flex">
<span>def <span class="ident">write_to_given_csv_file</span></span>(<span>file_object, to_write)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes given text to a given file object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to_write</code></strong></dt>
<dd>iterable to write to the csv file</dd>
<dt><strong><code>file_object</code></strong></dt>
<dd>the file object, created when opening a file
(e.g., "with open(file) as file_object:")</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def write_to_given_csv_file(file_object, to_write):
    &#34;&#34;&#34;Writes given text to a given file object.

    Args:
        to_write: iterable to write to the csv file
        file_object: the file object, created when opening a file
            (e.g., &#34;with open(file) as file_object:&#34;)

    Returns:
        Nothing
    &#34;&#34;&#34;
    try:
        writer = csv.writer(file_object, delimiter=&#39;,&#39;)
        writer.writerow(to_write)  # writes a row of the csv file using the list &#39;to_files&#39;
    except ValueError as exc:
        raise ValueError(
            &#34;I/O operation on closed file. Issue with FileHandler.open_label_file&#34;) \
            from exc</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="auto_osint_v.file_handler.FileHandler.clean_data_file"><code class="name flex">
<span>def <span class="ident">clean_data_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Removes all data in given file</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>name of file, can be path relative to 'data_files' directory</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_data_file(self, filename):
    &#34;&#34;&#34;Removes all data in given file

    Args:
        filename: name of file, can be path relative to &#39;data_files&#39; directory
    &#34;&#34;&#34;
    try:
        os.remove(os.path.join(self.data_file_path, filename))
    except FileNotFoundError:
        pass</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.create_potential_corroboration_file"><code class="name flex">
<span>def <span class="ident">create_potential_corroboration_file</span></span>(<span>self, sources_list_of_dicts)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the potential corroboration source store.</p>
<p>Writes the list of dictionaries to a csv file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sources_list_of_dicts</code></strong></dt>
<dd>Must be a list of dictionaries ( list[dict[x,y]] )</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>nothing, outputs to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_potential_corroboration_file(self, sources_list_of_dicts):
    &#34;&#34;&#34;Creates the potential corroboration source store.

    Writes the list of dictionaries to a csv file.

    Args:
        sources_list_of_dicts: Must be a list of dictionaries ( list[dict[x,y]] )

    Returns:
        nothing, outputs to file
    &#34;&#34;&#34;
    sources_file_path = self.data_file_path + &#34;potential_corroboration.csv&#34;
    try:
        self.clean_data_file(&#34;potential_corroboration.csv&#34;)
    except FileNotFoundError:
        pass
    # get keys of dictionary and store as fieldnames
    fieldnames = sources_list_of_dicts[0].keys()
    with open(sources_file_path, &#34;x&#34;, newline=&#34;&#34;, encoding=&#34;utf-8&#34;) as sources_file:
        # create writer object
        writer = csv.DictWriter(sources_file, fieldnames)
        writer.writeheader()
        # write the dictionary to csv
        writer.writerows(sources_list_of_dicts)</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.get_keywords_from_target_info"><code class="name flex">
<span>def <span class="ident">get_keywords_from_target_info</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets all the information that is stored in the 'Info' field in each target info file.</p>
<h2 id="returns">Returns</h2>
<p>All the info stored in /target_info_files/</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_keywords_from_target_info(self):
    &#34;&#34;&#34;Gets all the information that is stored in the &#39;Info&#39; field in each target info file.

    Returns:
        All the info stored in /target_info_files/
    &#34;&#34;&#34;
    # List of words that have no meaning without context
    irrelevant_words = [&#34;it&#34;, &#34;them&#34;, &#34;they&#34;, &#34;the&#34;, &#34;he&#34;, &#34;she&#34;, &#34;his&#34;, &#34;her&#34;, &#34;we&#34;, &#34;i&#34;,
                        &#34;us&#34;, &#34;me&#34;, &#34;my&#34;, &#34;here&#34;, &#34;our&#34;]
    # the directory to find the target info files
    target_files_dir = os.path.join(self.data_file_path, &#34;target_info_files/&#34;)
    # list target info files
    target_files = os.listdir(target_files_dir)
    # Create list to store keywords
    info_all = []
    # read each file individually
    for file in target_files:
        filepath = os.path.join(target_files_dir, file)
        frame = pd.read_csv(filepath, index_col=False)
        # appends every entry in the &#39;info&#39; column to the &#39;info_all&#39; list unless
        # it is irrelevant
        values = frame[&#34;Info&#34;].values.tolist()
        info_all.extend(values)
    # remove irrelevant words
    info_all = [word for word in info_all if word not in irrelevant_words]
    # return list after each file has been examined
    return info_all</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.get_output_path"><code class="name flex">
<span>def <span class="ident">get_output_path</span></span>(<span>self, postfix, file_ext)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets the path of the output file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_output_path(self, postfix, file_ext):
    &#34;&#34;&#34;Gets the path of the output file&#34;&#34;&#34;
    output_directory = self.data_file_path + &#34;output&#34;
    try:
        os.mkdir(output_directory)
        file_path = str(os.path.join(output_directory, f&#34;output{postfix}.{file_ext}&#34;))
    except FileExistsError:
        file_path = str(os.path.join(output_directory, f&#34;output{postfix}.{file_ext}&#34;))
    return file_path</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.open_evidence_file"><code class="name flex">
<span>def <span class="ident">open_evidence_file</span></span>(<span>self, to_write)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates/Opens evidence file and writes to it.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>to_write</code></strong></dt>
<dd>List of elements to write to file</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing - output to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_evidence_file(self, to_write):
    &#34;&#34;&#34;Creates/Opens evidence file and writes to it.

    Args:
        to_write: List of elements to write to file

    Returns:
        Nothing - output to file
    &#34;&#34;&#34;
    evidence_file_path = self.data_file_path + &#34;evidence_file.csv&#34;
    fieldnames = [&#34;evidence type&#34;, &#34;info&#34;, &#34;extra info&#34;, &#34;score&#34;, &#34;source link&#34;]
    try:
        with open(evidence_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
            # Creation of csv file
            writer = csv.DictWriter(evidence_file, fieldnames)
            writer.writeheader()
            # Write info to csv
            self.write_to_given_csv_file(evidence_file, to_write)
    except FileExistsError:
        with open(evidence_file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
            # Append info to csv
            self.write_to_given_csv_file(evidence_file, to_write)</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.open_label_file"><code class="name flex">
<span>def <span class="ident">open_label_file</span></span>(<span>self, label, text, mentions)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates/Opens label file directory and the label file itself.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong></dt>
<dd>The labelled word</dd>
<dt><strong><code>mentions</code></strong></dt>
<dd>The number of times the text has appeared.</dd>
<dt><strong><code>label</code></strong></dt>
<dd>This will be the name for the label file. This is the label associated with a
word</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Nothing - output to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_label_file(self, label, text, mentions):
    &#34;&#34;&#34;Creates/Opens label file directory and the label file itself.

    Args:
        text: The labelled word
        mentions: The number of times the text has appeared.
        label: This will be the name for the label file. This is the label associated with a
            word

    Returns:
        Nothing - output to file
    &#34;&#34;&#34;
    label_files_directory = self.data_file_path + &#34;target_info_files&#34;
    try:
        os.mkdir(label_files_directory)
        file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
    except FileExistsError:
        file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
    fieldnames = [&#39;Info&#39;, &#39;Mentions&#39;]
    try:
        with open(file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as label_file:
            # Creation of csv file
            writer = csv.DictWriter(label_file, fieldnames)
            # enter source type and key information
            writer.writeheader()
            # Write info to csv
            to_write = [text, mentions]
            self.write_to_given_csv_file(label_file, to_write)
    except FileExistsError:
        with open(file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as label_file:
            # Write info to csv
            to_write = [text, mentions]
            self.write_to_given_csv_file(label_file, to_write)</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.open_txt_file"><code class="name flex">
<span>def <span class="ident">open_txt_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Opens a file or creates one if it does not exist, returns the fileIO object.</p>
<p>Clean every temp file created here by using clean_directory.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>name of file to open</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>file object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_txt_file(self, filename):
    &#34;&#34;&#34;Opens a file or creates one if it does not exist, returns the fileIO object.

    Clean every temp file created here by using clean_directory.

    Args:
        filename: name of file to open

    Returns:
        file object
    &#34;&#34;&#34;
    try:
        return open(os.path.join(self.data_file_path, filename), &#34;a&#34;, encoding=&#34;utf-8&#34;)
    except FileNotFoundError:
        return open(os.path.join(self.data_file_path, filename), &#34;w&#34;, encoding=&#34;utf-8&#34;)</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.read_bias_file"><code class="name flex">
<span>def <span class="ident">read_bias_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_bias_file(self):
    bias_file_path = str(os.path.join(self.data_file_path, &#34;bias_sources.csv&#34;))
    with open(bias_file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as bfile:
        reader = csv.DictReader(bfile)
        list_of_dicts = list(reader)
        return list_of_dicts</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.read_evidence_file"><code class="name flex">
<span>def <span class="ident">read_evidence_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_evidence_file(self):
    evidence_file_path = self.data_file_path + &#34;evidence_file.csv&#34;
    with open(evidence_file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
        reader = csv.DictReader(evidence_file)
        list_of_dicts = list(reader)
        return list_of_dicts</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.read_file"><code class="name flex">
<span>def <span class="ident">read_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the given file. Reads any file, extension is included in filename.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>filename</code></strong></dt>
<dd>includes the file extension.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the contents of the file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_file(self, filename):
    &#34;&#34;&#34;Reads the given file. Reads any file, extension is included in filename.

    Args:
        filename: includes the file extension.

    Returns:
        the contents of the file
    &#34;&#34;&#34;
    file_path = str(os.path.join(self.data_file_path, filename))
    with open(file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as file:
        temp = file.read()
        file.close()
        return temp</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.write_bias_file"><code class="name flex">
<span>def <span class="ident">write_bias_file</span></span>(<span>self, info_analyser)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and writes to the bias information file.</p>
<p>This bias information is only useful for the user if they want to include information that
the tool cannot use, but may be relevant to their analysis or conclusions.</p>
<h2 id="returns">Returns</h2>
<p>nothing - output to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_bias_file(self, info_analyser):
    &#34;&#34;&#34;Creates and writes to the bias information file.

    This bias information is only useful for the user if they want to include information that
    the tool cannot use, but may be relevant to their analysis or conclusions.

    Returns:
        nothing - output to file
    &#34;&#34;&#34;
    bias_file_path = str(os.path.join(self.data_file_path, &#34;bias_sources.csv&#34;))
    with open(bias_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as bfile:
        fieldnames = [&#39;Type/Link&#39;, &#39;Key Info&#39;, &#39;Info Sentiment&#39;]
        writer = csv.DictWriter(bfile, fieldnames)
        # enter source type and key information
        writer.writeheader()
        option = &#34;&#34;
        while option not in {&#34;x&#34;, &#34;X&#34;}:
            source_type = str(input(&#34;If you wish to enter a source that has no URL, just enter &#34;
                                    &#34;the type of source (e.g. HUMINT, SIGINT, etc.).&#34;
                                    &#34;If it is an open source, please enter the URL.\n&gt;&gt;&gt; &#34;))
            key_info = str(input(&#34;Enter the key information proffered &#34;
                                 &#34;from this source/intelligence\n&gt;&gt;&gt; &#34;))
            writer.writerow({&#34;Type/Link&#34;: source_type, &#34;Key Info&#34;: key_info,
                             &#34;Info Sentiment&#34;: info_analyser(key_info)})
            option = str(input(&#34;Enter &#39;X&#39; to finish entering sources. &#34;
                               &#34;Press ENTER to add another source&gt;&gt;&gt; &#34;))
        bfile.close()</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.write_intel_file"><code class="name flex">
<span>def <span class="ident">write_intel_file</span></span>(<span>self, editor: bool)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and writes a file for the intelligence statement to be stored in.</p>
<p>This opens the file in the text editor for easier statement writing.</p>
<h2 id="returns">Returns</h2>
<p>nothing - output to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_intel_file(self, editor: bool):
    &#34;&#34;&#34;Creates and writes a file for the intelligence statement to be stored in.

    This opens the file in the text editor for easier statement writing.

    Returns:
        nothing - output to file
    &#34;&#34;&#34;
    intel_file_path = str(os.path.join(self.data_file_path, &#34;intelligence_file.txt&#34;))
    if os.path.isfile(intel_file_path):
        os.remove(intel_file_path)
    with open(intel_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as fout:
        # Create file and close as will be edited in txt editor.
        statement_help = str(&#34;Intelligence statement help:\n&#34;
                             &#34;- Please include as much information as possible.\n&#34;
                             &#34;- Include known associates to the person(s) mentioned.\n&#34;
                             &#34;- Remove this help section and replace it with your &#34;
                             &#34;intelligence statement.\n&#34;
                             &#34;- Be sure to save the file before continuing.&#34;)
        if editor:
            fout.write(statement_help)
            fout.close()
            webbrowser.open(intel_file_path)  # edit in default text editor
        else:
            statement = str(input(statement_help))
            fout.write(statement)
            fout.close()</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.write_to_txt_file_remove_duplicates"><code class="name flex">
<span>def <span class="ident">write_to_txt_file_remove_duplicates</span></span>(<span>self, file_object, to_write)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the given text and ensures no duplicates are written.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_object</code></strong></dt>
<dd>File object passed from opening the file.</dd>
<dt><strong><code>to_write</code></strong></dt>
<dd>The text to write.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_to_txt_file_remove_duplicates(self, file_object, to_write):
    &#34;&#34;&#34;Writes the given text and ensures no duplicates are written.

    Args:
        file_object: File object passed from opening the file.
        to_write: The text to write.
    &#34;&#34;&#34;
    # check whether lines are unique
    if to_write not in self.urls_present:
        # write to file
        file_object.write(to_write + &#34;\n&#34;)
        # add unique line to lines_present lines
        self.urls_present.append(to_write)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="auto_osint_v" href="index.html">auto_osint_v</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="auto_osint_v.file_handler.FileHandler" href="#auto_osint_v.file_handler.FileHandler">FileHandler</a></code></h4>
<ul class="">
<li><code><a title="auto_osint_v.file_handler.FileHandler.clean_data_file" href="#auto_osint_v.file_handler.FileHandler.clean_data_file">clean_data_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.clean_directory" href="#auto_osint_v.file_handler.FileHandler.clean_directory">clean_directory</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.close_file" href="#auto_osint_v.file_handler.FileHandler.close_file">close_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.create_potential_corroboration_file" href="#auto_osint_v.file_handler.FileHandler.create_potential_corroboration_file">create_potential_corroboration_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.get_keywords_from_target_info" href="#auto_osint_v.file_handler.FileHandler.get_keywords_from_target_info">get_keywords_from_target_info</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.get_output_path" href="#auto_osint_v.file_handler.FileHandler.get_output_path">get_output_path</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.open_evidence_file" href="#auto_osint_v.file_handler.FileHandler.open_evidence_file">open_evidence_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.open_label_file" href="#auto_osint_v.file_handler.FileHandler.open_label_file">open_label_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.open_txt_file" href="#auto_osint_v.file_handler.FileHandler.open_txt_file">open_txt_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.read_bias_file" href="#auto_osint_v.file_handler.FileHandler.read_bias_file">read_bias_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.read_evidence_file" href="#auto_osint_v.file_handler.FileHandler.read_evidence_file">read_evidence_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.read_file" href="#auto_osint_v.file_handler.FileHandler.read_file">read_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.write_bias_file" href="#auto_osint_v.file_handler.FileHandler.write_bias_file">write_bias_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.write_intel_file" href="#auto_osint_v.file_handler.FileHandler.write_intel_file">write_intel_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.write_to_given_csv_file" href="#auto_osint_v.file_handler.FileHandler.write_to_given_csv_file">write_to_given_csv_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.write_to_txt_file_remove_duplicates" href="#auto_osint_v.file_handler.FileHandler.write_to_txt_file_remove_duplicates">write_to_txt_file_remove_duplicates</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>