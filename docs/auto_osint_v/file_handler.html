<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>auto_osint_v.file_handler API documentation</title>
<meta name="description" content="This module handles all our data files. CSV or TXT." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>auto_osint_v.file_handler</code></h1>
</header>
<section id="section-intro">
<p>This module handles all our data files. CSV or TXT.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This module handles all our data files. CSV or TXT.
&#34;&#34;&#34;

import csv
import os
import webbrowser


def write_to_csv_file(file_object, to_write):
    &#34;&#34;&#34;
    Writes given text to a given file object.
    :param to_write: list of elements to write to csv file
    :param file_object: the file object, created when opening a file (e.g.,
    &#34;with open(file) as file_object:&#34;)
    :return: Nothing
    &#34;&#34;&#34;
    try:
        writer = csv.writer(file_object, delimiter=&#39;,&#39;)
        # this isn&#39;t right
        writer.writerow(to_write)  # writes a row of the csv file using the list &#39;to_files&#39;
    except ValueError as exc:
        raise ValueError(&#34;I/O operation on closed file. Issue with FileHandler.open_label_file&#34;) \
            from exc


class FileHandler:
    &#34;&#34;&#34;
    FileHandler class handles anything file related for the whole tool.
    This can be created as an object once and reused multiple times.
    &#34;&#34;&#34;
    def __init__(self, data_file):
        &#34;&#34;&#34;
        Initialises the FileHandler object
        :param data_file: the file path for all data files - likely &#39;./data_files/&#39;.
        &#34;&#34;&#34;
        self.data_file_path = data_file

    def write_bias_file(self):
        &#34;&#34;&#34;
        Creates and writes to the bias information file.
        This bias information is only useful for the user if they want to include information that
        the tool cannot use, but may be relevant to their analysis or conclusions.
        :return: nothing - output to file
        &#34;&#34;&#34;
        bias_file_path = str(os.path.join(self.data_file_path, &#34;bias_sources.csv&#34;))
        with open(bias_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as bfile:
            fieldnames = [&#39;Type&#39;, &#39;Key_Info&#39;]
            writer = csv.DictWriter(bfile, fieldnames)
            # enter source type and key information
            writer.writeheader()
            option = &#34;&#34;
            while option not in {&#34;x&#34;, &#34;X&#34;}:
                source_type = str(input(&#34;Enter the source/intelligence type, &#34;
                                        &#34;for example HUMINT, SIGINT, etc.\n&gt;&gt;&gt; &#34;))
                key_info = str(input(&#34;Enter the key information proffered &#34;
                                     &#34;from this source/intelligence\n&gt;&gt;&gt; &#34;))
                writer.writerow({&#34;Type&#34;: source_type, &#34;Key_Info&#34;: key_info})
                option = str(input(&#34;Enter &#39;X&#39; to finish entering sources. &#34;
                                   &#34;Press ENTER to add another source&gt;&gt;&gt; &#34;))
            bfile.close()

    def write_intel_file(self):
        &#34;&#34;&#34;
        Creates and writes a file for the intelligence statement to be stored in.
        This opens the file in the text editor for easier statement writing.
        :return: nothing - output to file
        &#34;&#34;&#34;
        intel_file_path = str(os.path.join(self.data_file_path, &#34;intelligence_file.txt&#34;))
        if os.path.isfile(intel_file_path):
            os.remove(intel_file_path)
        with open(intel_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as fout:
            # Create file and close as will be edited in txt editor.
            statement_help = str(&#34;Intelligence statement help:\n&#34;
                                 &#34;- Please include as much information as possible.\n&#34;
                                 &#34;- Include known associates to the person(s) mentioned.\n&#34;
                                 &#34;- Remove this help section and replace it with your &#34;
                                 &#34;intelligence statement.\n&#34;
                                 &#34;- Be sure to save the file before continuing.&#34;)
            fout.write(statement_help)
            fout.close()
            webbrowser.open(intel_file_path)  # edit in chosen text editor

    def read_file(self, filename):
        &#34;&#34;&#34;
        Reads the given file. Reads any file, extension is included in filename.
        :param filename: includes the file extension.
        :return: the contents of the file
        &#34;&#34;&#34;
        file_path = str(os.path.join(self.data_file_path, filename))
        with open(file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as file:
            temp = file.read()
            file.close()
            return temp

    @staticmethod
    def clean_directory(directory):
        &#34;&#34;&#34;
        Cleans the given directory. Removes all files inside.
        :return:
        &#34;&#34;&#34;
        for file in os.listdir(directory):
            os.remove(os.path.join(directory, file))

    def open_label_file(self, label, text, alias):
        &#34;&#34;&#34;
        Creates/Opens label file directory and the label file itself
        :param text: The labelled word
        :param alias: An alias for the information labelled.
        :param label: This will be the name for the label file. This is the label associated with a
        word
        :return: Nothing - output to file
        &#34;&#34;&#34;
        label_files_directory = self.data_file_path + &#34;target_info_files&#34;
        try:
            os.mkdir(label_files_directory)
            file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
        except FileExistsError:
            file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
        fieldnames = [&#39;Info&#39;, &#39;Alias&#39;]
        try:
            with open(file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as label_file:
                # Creation of csv file
                writer = csv.DictWriter(label_file, fieldnames)
                # enter source type and key information
                writer.writeheader()
                # Write info to csv
                to_write = [text, alias]
                write_to_csv_file(label_file, to_write)
        except FileExistsError:
            with open(file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as label_file:
                # Write info to csv
                to_write = [text, alias]
                write_to_csv_file(label_file, to_write)

    def open_evidence_file(self, to_write):
        &#34;&#34;&#34;
        Creates/Opens evidence file and writes to it.
        :type to_write: List of elements to write to file
        :return: Nothing - output to file
        &#34;&#34;&#34;
        evidence_file_path = self.data_file_path + &#34;evidence_file.csv&#34;
        fieldnames = [&#34;evidence type&#34;, &#34;info&#34;, &#34;extra info&#34;, &#34;score&#34;, &#34;source link&#34;]
        try:
            with open(evidence_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
                # Creation of csv file
                writer = csv.DictWriter(evidence_file, fieldnames)
                # enter source type and key information
                writer.writeheader()
                # Write info to csv
                write_to_csv_file(evidence_file, to_write)
        except FileExistsError:
            with open(evidence_file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
                # Append info to csv
                write_to_csv_file(evidence_file, to_write)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="auto_osint_v.file_handler.write_to_csv_file"><code class="name flex">
<span>def <span class="ident">write_to_csv_file</span></span>(<span>file_object, to_write)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes given text to a given file object.
:param to_write: list of elements to write to csv file
:param file_object: the file object, created when opening a file (e.g.,
"with open(file) as file_object:")
:return: Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_to_csv_file(file_object, to_write):
    &#34;&#34;&#34;
    Writes given text to a given file object.
    :param to_write: list of elements to write to csv file
    :param file_object: the file object, created when opening a file (e.g.,
    &#34;with open(file) as file_object:&#34;)
    :return: Nothing
    &#34;&#34;&#34;
    try:
        writer = csv.writer(file_object, delimiter=&#39;,&#39;)
        # this isn&#39;t right
        writer.writerow(to_write)  # writes a row of the csv file using the list &#39;to_files&#39;
    except ValueError as exc:
        raise ValueError(&#34;I/O operation on closed file. Issue with FileHandler.open_label_file&#34;) \
            from exc</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="auto_osint_v.file_handler.FileHandler"><code class="flex name class">
<span>class <span class="ident">FileHandler</span></span>
<span>(</span><span>data_file)</span>
</code></dt>
<dd>
<div class="desc"><p>FileHandler class handles anything file related for the whole tool.
This can be created as an object once and reused multiple times.</p>
<p>Initialises the FileHandler object
:param data_file: the file path for all data files - likely './data_files/'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileHandler:
    &#34;&#34;&#34;
    FileHandler class handles anything file related for the whole tool.
    This can be created as an object once and reused multiple times.
    &#34;&#34;&#34;
    def __init__(self, data_file):
        &#34;&#34;&#34;
        Initialises the FileHandler object
        :param data_file: the file path for all data files - likely &#39;./data_files/&#39;.
        &#34;&#34;&#34;
        self.data_file_path = data_file

    def write_bias_file(self):
        &#34;&#34;&#34;
        Creates and writes to the bias information file.
        This bias information is only useful for the user if they want to include information that
        the tool cannot use, but may be relevant to their analysis or conclusions.
        :return: nothing - output to file
        &#34;&#34;&#34;
        bias_file_path = str(os.path.join(self.data_file_path, &#34;bias_sources.csv&#34;))
        with open(bias_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as bfile:
            fieldnames = [&#39;Type&#39;, &#39;Key_Info&#39;]
            writer = csv.DictWriter(bfile, fieldnames)
            # enter source type and key information
            writer.writeheader()
            option = &#34;&#34;
            while option not in {&#34;x&#34;, &#34;X&#34;}:
                source_type = str(input(&#34;Enter the source/intelligence type, &#34;
                                        &#34;for example HUMINT, SIGINT, etc.\n&gt;&gt;&gt; &#34;))
                key_info = str(input(&#34;Enter the key information proffered &#34;
                                     &#34;from this source/intelligence\n&gt;&gt;&gt; &#34;))
                writer.writerow({&#34;Type&#34;: source_type, &#34;Key_Info&#34;: key_info})
                option = str(input(&#34;Enter &#39;X&#39; to finish entering sources. &#34;
                                   &#34;Press ENTER to add another source&gt;&gt;&gt; &#34;))
            bfile.close()

    def write_intel_file(self):
        &#34;&#34;&#34;
        Creates and writes a file for the intelligence statement to be stored in.
        This opens the file in the text editor for easier statement writing.
        :return: nothing - output to file
        &#34;&#34;&#34;
        intel_file_path = str(os.path.join(self.data_file_path, &#34;intelligence_file.txt&#34;))
        if os.path.isfile(intel_file_path):
            os.remove(intel_file_path)
        with open(intel_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as fout:
            # Create file and close as will be edited in txt editor.
            statement_help = str(&#34;Intelligence statement help:\n&#34;
                                 &#34;- Please include as much information as possible.\n&#34;
                                 &#34;- Include known associates to the person(s) mentioned.\n&#34;
                                 &#34;- Remove this help section and replace it with your &#34;
                                 &#34;intelligence statement.\n&#34;
                                 &#34;- Be sure to save the file before continuing.&#34;)
            fout.write(statement_help)
            fout.close()
            webbrowser.open(intel_file_path)  # edit in chosen text editor

    def read_file(self, filename):
        &#34;&#34;&#34;
        Reads the given file. Reads any file, extension is included in filename.
        :param filename: includes the file extension.
        :return: the contents of the file
        &#34;&#34;&#34;
        file_path = str(os.path.join(self.data_file_path, filename))
        with open(file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as file:
            temp = file.read()
            file.close()
            return temp

    @staticmethod
    def clean_directory(directory):
        &#34;&#34;&#34;
        Cleans the given directory. Removes all files inside.
        :return:
        &#34;&#34;&#34;
        for file in os.listdir(directory):
            os.remove(os.path.join(directory, file))

    def open_label_file(self, label, text, alias):
        &#34;&#34;&#34;
        Creates/Opens label file directory and the label file itself
        :param text: The labelled word
        :param alias: An alias for the information labelled.
        :param label: This will be the name for the label file. This is the label associated with a
        word
        :return: Nothing - output to file
        &#34;&#34;&#34;
        label_files_directory = self.data_file_path + &#34;target_info_files&#34;
        try:
            os.mkdir(label_files_directory)
            file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
        except FileExistsError:
            file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
        fieldnames = [&#39;Info&#39;, &#39;Alias&#39;]
        try:
            with open(file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as label_file:
                # Creation of csv file
                writer = csv.DictWriter(label_file, fieldnames)
                # enter source type and key information
                writer.writeheader()
                # Write info to csv
                to_write = [text, alias]
                write_to_csv_file(label_file, to_write)
        except FileExistsError:
            with open(file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as label_file:
                # Write info to csv
                to_write = [text, alias]
                write_to_csv_file(label_file, to_write)

    def open_evidence_file(self, to_write):
        &#34;&#34;&#34;
        Creates/Opens evidence file and writes to it.
        :type to_write: List of elements to write to file
        :return: Nothing - output to file
        &#34;&#34;&#34;
        evidence_file_path = self.data_file_path + &#34;evidence_file.csv&#34;
        fieldnames = [&#34;evidence type&#34;, &#34;info&#34;, &#34;extra info&#34;, &#34;score&#34;, &#34;source link&#34;]
        try:
            with open(evidence_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
                # Creation of csv file
                writer = csv.DictWriter(evidence_file, fieldnames)
                # enter source type and key information
                writer.writeheader()
                # Write info to csv
                write_to_csv_file(evidence_file, to_write)
        except FileExistsError:
            with open(evidence_file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
                # Append info to csv
                write_to_csv_file(evidence_file, to_write)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="auto_osint_v.file_handler.FileHandler.clean_directory"><code class="name flex">
<span>def <span class="ident">clean_directory</span></span>(<span>directory)</span>
</code></dt>
<dd>
<div class="desc"><p>Cleans the given directory. Removes all files inside.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def clean_directory(directory):
    &#34;&#34;&#34;
    Cleans the given directory. Removes all files inside.
    :return:
    &#34;&#34;&#34;
    for file in os.listdir(directory):
        os.remove(os.path.join(directory, file))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="auto_osint_v.file_handler.FileHandler.open_evidence_file"><code class="name flex">
<span>def <span class="ident">open_evidence_file</span></span>(<span>self, to_write)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates/Opens evidence file and writes to it.
:type to_write: List of elements to write to file
:return: Nothing - output to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_evidence_file(self, to_write):
    &#34;&#34;&#34;
    Creates/Opens evidence file and writes to it.
    :type to_write: List of elements to write to file
    :return: Nothing - output to file
    &#34;&#34;&#34;
    evidence_file_path = self.data_file_path + &#34;evidence_file.csv&#34;
    fieldnames = [&#34;evidence type&#34;, &#34;info&#34;, &#34;extra info&#34;, &#34;score&#34;, &#34;source link&#34;]
    try:
        with open(evidence_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
            # Creation of csv file
            writer = csv.DictWriter(evidence_file, fieldnames)
            # enter source type and key information
            writer.writeheader()
            # Write info to csv
            write_to_csv_file(evidence_file, to_write)
    except FileExistsError:
        with open(evidence_file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as evidence_file:
            # Append info to csv
            write_to_csv_file(evidence_file, to_write)</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.open_label_file"><code class="name flex">
<span>def <span class="ident">open_label_file</span></span>(<span>self, label, text, alias)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates/Opens label file directory and the label file itself
:param text: The labelled word
:param alias: An alias for the information labelled.
:param label: This will be the name for the label file. This is the label associated with a
word
:return: Nothing - output to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def open_label_file(self, label, text, alias):
    &#34;&#34;&#34;
    Creates/Opens label file directory and the label file itself
    :param text: The labelled word
    :param alias: An alias for the information labelled.
    :param label: This will be the name for the label file. This is the label associated with a
    word
    :return: Nothing - output to file
    &#34;&#34;&#34;
    label_files_directory = self.data_file_path + &#34;target_info_files&#34;
    try:
        os.mkdir(label_files_directory)
        file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
    except FileExistsError:
        file_path = str(os.path.join(label_files_directory, label + &#34;.csv&#34;))
    fieldnames = [&#39;Info&#39;, &#39;Alias&#39;]
    try:
        with open(file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as label_file:
            # Creation of csv file
            writer = csv.DictWriter(label_file, fieldnames)
            # enter source type and key information
            writer.writeheader()
            # Write info to csv
            to_write = [text, alias]
            write_to_csv_file(label_file, to_write)
    except FileExistsError:
        with open(file_path, &#34;a&#34;, encoding=&#34;utf-8&#34;) as label_file:
            # Write info to csv
            to_write = [text, alias]
            write_to_csv_file(label_file, to_write)</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.read_file"><code class="name flex">
<span>def <span class="ident">read_file</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads the given file. Reads any file, extension is included in filename.
:param filename: includes the file extension.
:return: the contents of the file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_file(self, filename):
    &#34;&#34;&#34;
    Reads the given file. Reads any file, extension is included in filename.
    :param filename: includes the file extension.
    :return: the contents of the file
    &#34;&#34;&#34;
    file_path = str(os.path.join(self.data_file_path, filename))
    with open(file_path, &#34;r&#34;, encoding=&#34;utf-8&#34;) as file:
        temp = file.read()
        file.close()
        return temp</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.write_bias_file"><code class="name flex">
<span>def <span class="ident">write_bias_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and writes to the bias information file.
This bias information is only useful for the user if they want to include information that
the tool cannot use, but may be relevant to their analysis or conclusions.
:return: nothing - output to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_bias_file(self):
    &#34;&#34;&#34;
    Creates and writes to the bias information file.
    This bias information is only useful for the user if they want to include information that
    the tool cannot use, but may be relevant to their analysis or conclusions.
    :return: nothing - output to file
    &#34;&#34;&#34;
    bias_file_path = str(os.path.join(self.data_file_path, &#34;bias_sources.csv&#34;))
    with open(bias_file_path, &#34;w&#34;, encoding=&#34;utf-8&#34;) as bfile:
        fieldnames = [&#39;Type&#39;, &#39;Key_Info&#39;]
        writer = csv.DictWriter(bfile, fieldnames)
        # enter source type and key information
        writer.writeheader()
        option = &#34;&#34;
        while option not in {&#34;x&#34;, &#34;X&#34;}:
            source_type = str(input(&#34;Enter the source/intelligence type, &#34;
                                    &#34;for example HUMINT, SIGINT, etc.\n&gt;&gt;&gt; &#34;))
            key_info = str(input(&#34;Enter the key information proffered &#34;
                                 &#34;from this source/intelligence\n&gt;&gt;&gt; &#34;))
            writer.writerow({&#34;Type&#34;: source_type, &#34;Key_Info&#34;: key_info})
            option = str(input(&#34;Enter &#39;X&#39; to finish entering sources. &#34;
                               &#34;Press ENTER to add another source&gt;&gt;&gt; &#34;))
        bfile.close()</code></pre>
</details>
</dd>
<dt id="auto_osint_v.file_handler.FileHandler.write_intel_file"><code class="name flex">
<span>def <span class="ident">write_intel_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates and writes a file for the intelligence statement to be stored in.
This opens the file in the text editor for easier statement writing.
:return: nothing - output to file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_intel_file(self):
    &#34;&#34;&#34;
    Creates and writes a file for the intelligence statement to be stored in.
    This opens the file in the text editor for easier statement writing.
    :return: nothing - output to file
    &#34;&#34;&#34;
    intel_file_path = str(os.path.join(self.data_file_path, &#34;intelligence_file.txt&#34;))
    if os.path.isfile(intel_file_path):
        os.remove(intel_file_path)
    with open(intel_file_path, &#34;x&#34;, encoding=&#34;utf-8&#34;) as fout:
        # Create file and close as will be edited in txt editor.
        statement_help = str(&#34;Intelligence statement help:\n&#34;
                             &#34;- Please include as much information as possible.\n&#34;
                             &#34;- Include known associates to the person(s) mentioned.\n&#34;
                             &#34;- Remove this help section and replace it with your &#34;
                             &#34;intelligence statement.\n&#34;
                             &#34;- Be sure to save the file before continuing.&#34;)
        fout.write(statement_help)
        fout.close()
        webbrowser.open(intel_file_path)  # edit in chosen text editor</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="auto_osint_v" href="index.html">auto_osint_v</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="auto_osint_v.file_handler.write_to_csv_file" href="#auto_osint_v.file_handler.write_to_csv_file">write_to_csv_file</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="auto_osint_v.file_handler.FileHandler" href="#auto_osint_v.file_handler.FileHandler">FileHandler</a></code></h4>
<ul class="two-column">
<li><code><a title="auto_osint_v.file_handler.FileHandler.clean_directory" href="#auto_osint_v.file_handler.FileHandler.clean_directory">clean_directory</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.open_evidence_file" href="#auto_osint_v.file_handler.FileHandler.open_evidence_file">open_evidence_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.open_label_file" href="#auto_osint_v.file_handler.FileHandler.open_label_file">open_label_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.read_file" href="#auto_osint_v.file_handler.FileHandler.read_file">read_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.write_bias_file" href="#auto_osint_v.file_handler.FileHandler.write_bias_file">write_bias_file</a></code></li>
<li><code><a title="auto_osint_v.file_handler.FileHandler.write_intel_file" href="#auto_osint_v.file_handler.FileHandler.write_intel_file">write_intel_file</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>